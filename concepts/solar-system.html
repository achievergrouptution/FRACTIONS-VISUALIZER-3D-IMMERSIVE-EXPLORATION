<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOLAR SYSTEM ¬∑ 3D Space Exploration</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', 'Arial', sans-serif; background: black; }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(5, 5, 20, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid #ffaa33;
            border-radius: 40px;
            padding: 16px 28px;
            box-shadow: 0 0 40px #ffaa3366;
            z-index: 20;
            pointer-events: none;
            border-left: 4px solid gold;
        }
        #hud h1 {
            margin: 0;
            font-size: 2rem;
            letter-spacing: 4px;
            text-shadow: 0 0 20px gold;
            color: #fff6cc;
        }
        #hud .sub {
            margin: 5px 0 0;
            opacity: 0.8;
            font-style: italic;
        }
        #planet-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 8, 20, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid #44ccff;
            border-radius: 40px;
            padding: 22px 35px;
            color: #e0f0ff;
            width: 350px;
            box-shadow: 0 0 60px #00aaff88;
            z-index: 25;
            pointer-events: none;
            border-bottom: 4px solid cyan;
            transform: translateY(0);
            transition: opacity 0.3s;
        }
        #planet-name {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 5px;
            text-shadow: 0 0 20px cyan;
            color: #aaf0ff;
        }
        #planet-fact {
            font-size: 1.2rem;
            margin-bottom: 15px;
            line-height: 1.5;
            color: #ccffff;
        }
        #planet-stats {
            display: flex;
            gap: 25px;
            font-size: 1.1rem;
            border-top: 1px solid #336688;
            padding-top: 12px;
        }
        .stat {
            display: flex;
            flex-direction: column;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #99ccff;
        }
        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(45deg, #0ef, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #controls-note {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(20, 0, 30, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid #ff66aa;
            border-radius: 30px;
            padding: 12px 22px;
            color: #ffb0dd;
            font-size: 0.95rem;
            box-shadow: 0 0 30px #ff44aa;
            z-index: 15;
            pointer-events: none;
        }
        #footer {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #acf;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            padding: 4px 22px;
            border-radius: 40px;
            border: 1px solid #7af;
            z-index: 30;
            font-size: 0.9rem;
        }
        .clickable {
            cursor: pointer;
        }
        #zoom-prompt {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,30,30,0.7);
            backdrop-filter: blur(5px);
            border: 1px solid #0ff;
            border-radius: 40px;
            padding: 10px 24px;
            color: #aff;
            font-size: 1rem;
            box-shadow: 0 0 30px cyan;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="hud">
        <h1>üåå SOLAR SYSTEM EXPLORER</h1>
        <div class="sub">click any planet ¬∑ fly through space ¬∑ cinematic documentary</div>
    </div>
    <div id="zoom-prompt">ü™ê scroll to zoom into surface</div>
    <div id="planet-panel">
        <div id="planet-name">üåç Earth</div>
        <div id="planet-fact">The only known planet with life. 71% covered in water.</div>
        <div id="planet-stats">
            <div class="stat"><span class="stat-label">Diameter</span><span class="stat-value" id="stat-dia">12,742 km</span></div>
            <div class="stat"><span class="stat-label">Orbit period</span><span class="stat-value" id="stat-orbit">365 days</span></div>
            <div class="stat"><span class="stat-label">Temp</span><span class="stat-value" id="stat-temp">15¬∞C</span></div>
        </div>
    </div>
    <div id="controls-note">
        ‚ö° click planet ‚Üí travel & facts ¬∑ drag to orbit ¬∑ scroll zoom
    </div>
    <div id="footer">¬© 2026 ACHIEVER GROUP TUTIONS ¬∑ 3D SPACE EXPLORATION</div>

    <!-- Three.js imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js'; // just for fun? no, keep clean
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        
        // --- SETUP SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x030311);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.8;
        document.body.appendChild(renderer.domElement);

        // Controls (cinematic damping)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false;
        controls.enableZoom = true;
        controls.maxDistance = 150;
        controls.minDistance = 5;
        controls.target.set(0, 0, 0);

        // --- POST PROCESSING (glow + film grain for documentary feel) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.3, 0.8);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.4;

        const filmPass = new FilmPass(0.2, 0.5, 2048, false);
        filmPass.renderToScreen = true;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(filmPass);

        // --- LIGHT & LENS FLARE (simulated via point light + sprite) ---
        // Sun light
        const sunLight = new THREE.PointLight(0xffeedd, 2.0, 0, 0);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        // Lens flare sprite (glowing sun)
        const sunGlowTexture = (() => {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,220,150,1)');
            gradient.addColorStop(0.4, 'rgba(255,200,100,0.8)');
            gradient.addColorStop(0.7, 'rgba(255,100,50,0.3)');
            gradient.addColorStop(1, 'rgba(255,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        })();

        const sunSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: sunGlowTexture, blending: THREE.AdditiveBlending }));
        sunSprite.scale.set(8, 8, 1);
        sunSprite.position.set(0, 0, 0);
        scene.add(sunSprite);

        // --- BACKGROUND NEBULA (cube texture or starfield? Use particle system) ---
        // star particles
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 4000;
        const starsPos = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount; i++) {
            starsPos[i*3] = (Math.random() - 0.5) * 400;
            starsPos[i*3+1] = (Math.random() - 0.5) * 400;
            starsPos[i*3+2] = (Math.random() - 0.5) * 400;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.25, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const stars = new THREE.Points(starsGeo, starsMat);
        scene.add(stars);

        // Nebula clouds (few large transparent blobs)
        const cloudMat = new THREE.MeshPhongMaterial({ color: 0x8866cc, emissive: 0x220044, transparent: true, opacity: 0.08, side: THREE.BackSide });
        const cloudGeo = new THREE.SphereGeometry(80, 32, 32);
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        scene.add(cloud);

        const cloud2Mat = new THREE.MeshPhongMaterial({ color: 0x4488aa, emissive: 0x002244, transparent: true, opacity: 0.06, side: THREE.BackSide });
        const cloud2 = new THREE.Mesh(new THREE.SphereGeometry(100, 32, 32), cloud2Mat);
        scene.add(cloud2);

        // --- PLANETS DATA ---
        const planetsInfo = [
            { name: 'Mercury', color: 0xaaaaaa, size: 0.4, distance: 4.5, speed: 0.02, fact: 'Closest to Sun. Surface temperatures vary from -173¬∞C to 427¬∞C.', diameter: '4,879 km', orbit: '88 days', temp: '167¬∞C' },
            { name: 'Venus', color: 0xffcc88, size: 0.6, distance: 6.5, speed: 0.015, fact: 'Hottest planet. Thick CO‚ÇÇ atmosphere, sulfuric acid clouds.', diameter: '12,104 km', orbit: '225 days', temp: '462¬∞C' },
            { name: 'Earth', color: 0x2288ff, size: 0.7, distance: 8.5, speed: 0.01, fact: 'Home. Only known planet with life. 71% ocean.', diameter: '12,742 km', orbit: '365 days', temp: '15¬∞C' },
            { name: 'Mars', color: 0xcc6633, size: 0.6, distance: 10.5, speed: 0.008, fact: 'The Red Planet. Has largest volcano in solar system.', diameter: '6,779 km', orbit: '687 days', temp: '-65¬∞C' },
            { name: 'Jupiter', color: 0xddbb99, size: 1.4, distance: 14.0, speed: 0.005, fact: 'Largest planet. Great Red Spot storm for 400 years.', diameter: '139,820 km', orbit: '12 years', temp: '-110¬∞C' },
            { name: 'Saturn', color: 0xeebb88, size: 1.2, distance: 18.0, speed: 0.003, fact: 'Magnificent rings made of ice and rock.', diameter: '116,460 km', orbit: '29 years', temp: '-140¬∞C' },
            { name: 'Uranus', color: 0xaaddff, size: 1.0, distance: 22.0, speed: 0.002, fact: 'Rotates on its side. Faint ring system.', diameter: '50,724 km', orbit: '84 years', temp: '-195¬∞C' },
            { name: 'Neptune', color: 0x3366ff, size: 1.0, distance: 26.0, speed: 0.0015, fact: 'Windiest planet. Supersonic winds up to 2,100 km/h.', diameter: '49,244 km', orbit: '165 years', temp: '-200¬∞C' }
        ];

        // Store planet meshes for animation/interaction
        const planets = [];
        const orbits = [];

        // create sun
        const sunGeo = new THREE.SphereGeometry(1.8, 64, 64);
        const sunMat = new THREE.MeshStandardMaterial({ color: 0xffaa44, emissive: 0xff5500 });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        // orbital trails (glowing rings)
        planetsInfo.forEach((p, i) => {
            const orbitRadius = p.distance;
            const points = [];
            const segments = 128;
            for (let j = 0; j <= segments; j++) {
                const angle = (j / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(Math.cos(angle) * orbitRadius, 0, Math.sin(angle) * orbitRadius));
            }
            const orbitGeo = new THREE.BufferGeometry().setFromPoints(points);
            const orbitMat = new THREE.LineBasicMaterial({ color: 0x44aaff, opacity: 0.25, transparent: true });
            const orbitLine = new THREE.LineLoop(orbitGeo, orbitMat);
            scene.add(orbitLine);
            orbits.push(orbitLine);
        });

        // create planets and rings for Saturn
        planetsInfo.forEach((info, idx) => {
            const geo = new THREE.SphereGeometry(info.size, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: info.color, emissive: 0x222222 });
            const planet = new THREE.Mesh(geo, mat);
            planet.userData = { ...info, index: idx };
            
            // random starting angle
            const angle = (idx / planetsInfo.length) * Math.PI * 2;
            planet.position.x = Math.cos(angle) * info.distance;
            planet.position.z = Math.sin(angle) * info.distance;
            
            scene.add(planet);
            planets.push(planet);

            // add ring for Saturn (idx 5)
            if (idx === 5) {
                const ringGeo = new THREE.TorusGeometry(info.size * 1.6, 0.15, 16, 100);
                const ringMat = new THREE.MeshStandardMaterial({ color: 0xccaa88, emissive: 0x332211, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.rotation.z = 0.3;
                planet.add(ring);
            }
            
            // tiny random moon for Earth (idx 2) ‚Äì just for fun
            if (idx === 2) {
                const moonGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const moonMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                const moon = new THREE.Mesh(moonGeo, moonMat);
                moon.position.set(1.0, 0.2, 0.5);
                planet.add(moon);
            }
        });

        // --- ASTEROID BELT (between Mars and Jupiter) ---
        const asteroidCount = 800;
        const asteroidGroup = new THREE.Group();
        for (let i = 0; i < asteroidCount; i++) {
            const r = 12.0 + Math.random() * 2.5; // distance range
            const angle = Math.random() * Math.PI * 2;
            const yOffset = (Math.random() - 0.5) * 0.8;
            
            const geo = new THREE.DodecahedronGeometry(0.08 + Math.random()*0.1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xaa9966 });
            const asteroid = new THREE.Mesh(geo, mat);
            asteroid.position.x = Math.cos(angle) * r;
            asteroid.position.z = Math.sin(angle) * r;
            asteroid.position.y = yOffset;
            asteroid.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            asteroidGroup.add(asteroid);
        }
        scene.add(asteroidGroup);

        // --- INTERACTION (raycaster) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets);
            
            if (intersects.length > 0) {
                const planet = intersects[0].object;
                const data = planet.userData;
                
                // update info panel
                document.getElementById('planet-name').innerHTML = `ü™ê ${data.name}`;
                document.getElementById('planet-fact').textContent = data.fact;
                document.getElementById('stat-dia').textContent = data.diameter;
                document.getElementById('stat-orbit').textContent = data.orbit;
                document.getElementById('stat-temp').textContent = data.temp;
                
                // gently move camera towards planet (travel effect)
                // simple: tween camera? just snap for demo, but we can lerp
                // we'll just set controls target to planet and move camera closer
                controls.target.copy(planet.position);
                // smoothly move camera a bit closer
                const direction = camera.position.clone().sub(planet.position).normalize();
                const newPos = planet.position.clone().add(direction.multiplyScalar(5));
                // simple lerp not implemented, but we set directly for demo (feels like jump)
                camera.position.copy(newPos);
                controls.update();
            }
        });

        // hover effect
        renderer.domElement.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        });

        // --- ANIMATION LOOP ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;

            // rotate planets around sun
            planets.forEach((planet, i) => {
                const data = planetsInfo[i];
                // increment angle based on speed
                const angle = time * data.speed * 1.5; // multiplier for visible motion
                planet.position.x = Math.cos(angle + i) * data.distance;
                planet.position.z = Math.sin(angle + i) * data.distance;
                // slight axial tilt
                planet.rotation.y += 0.01;
            });

            // rotate asteroid belt slowly
            asteroidGroup.rotation.y += 0.0002;

            // rotate stars very slowly
            stars.rotation.y += 0.00005;

            // update controls
            controls.update();

            // render
            composer.render();

            requestAnimationFrame(animate);
        }

        animate();

        // resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // initialize with Earth data
        setTimeout(() => {
            document.getElementById('planet-name').innerHTML = 'üåç Earth';
            document.getElementById('planet-fact').textContent = planetsInfo[2].fact;
            document.getElementById('stat-dia').textContent = planetsInfo[2].diameter;
            document.getElementById('stat-orbit').textContent = planetsInfo[2].orbit;
            document.getElementById('stat-temp').textContent = planetsInfo[2].temp;
        }, 500);
    </script>
</body>
</html>
