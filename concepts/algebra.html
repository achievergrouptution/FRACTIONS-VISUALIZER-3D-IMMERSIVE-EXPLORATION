<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algebra Graph Explorer ¬∑ 3D Coordinate Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: 'Segoe UI', 'Inter', sans-serif; }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(5, 10, 20, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid #00ffff;
            border-radius: 32px;
            padding: 20px 30px;
            color: white;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            z-index: 10;
            pointer-events: none;
        }
        #hud h1 {
            margin: 0 0 8px 0;
            font-weight: 400;
            font-size: 2.2rem;
            letter-spacing: 4px;
            text-shadow: 0 0 20px cyan;
            color: #bbffff;
        }
        #hud .sub {
            margin: 0;
            opacity: 0.8;
            border-left: 3px solid cyan;
            padding-left: 15px;
        }
        #control-panel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 10, 25, 0.8);
            backdrop-filter: blur(16px);
            border: 1px solid #ff66cc;
            border-radius: 40px;
            padding: 28px 30px;
            width: 300px;
            color: #fff;
            box-shadow: 0 0 60px #ff44aa88;
            z-index: 20;
            pointer-events: auto;
            border-left: 4px solid #f0f;
        }
        #control-panel h3 {
            margin: 0 0 25px 0;
            font-weight: 300;
            font-size: 1.8rem;
            color: #ffaaff;
            text-align: center;
            text-shadow: 0 0 15px magenta;
        }
        .slider-group {
            margin-bottom: 30px;
        }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            color: #aaf;
            font-size: 1.1rem;
            letter-spacing: 1px;
        }
        input[type=range] {
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #0ff, #f0f);
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            margin-top: 8px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 25px #0ff;
            border: 2px solid cyan;
            cursor: pointer;
        }
        .param-value {
            font-family: 'Courier New', monospace;
            color: #ffcc88;
            font-size: 1.3rem;
        }
        #eq-display {
            text-align: center;
            font-size: 2rem;
            margin: 20px 0 10px;
            background: rgba(0,255,255,0.1);
            padding: 15px;
            border-radius: 50px;
            border: 1px dashed #f0f;
            letter-spacing: 2px;
        }
        #footer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #8cf;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            padding: 6px 24px;
            border-radius: 40px;
            border: 1px solid #3cf;
            z-index: 30;
            font-size: 0.95rem;
        }
        #zoom-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,20,40,0.6);
            backdrop-filter: blur(5px);
            border: 1px solid #ffaa00;
            border-radius: 30px;
            padding: 12px 24px;
            color: #ffea88;
            font-size: 1rem;
            box-shadow: 0 0 30px orange;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="hud">
        <h1>‚úß ALGEBRA GRAPH EXPLORER ‚úß</h1>
        <div class="sub">fly inside the equation ¬∑ stretch ¬∑ reflect ¬∑ translate</div>
    </div>
    <div id="zoom-hint">‚õ∂ scroll to zoom into curve surface</div>

    <div id="control-panel">
        <h3>‚ö° PARAMETER LAB</h3>
        <div id="eq-display"><span style="color:#0ff">y</span> = <span id="a-val" class="param-value">1.0</span> <span style="color:#f0f">¬∑ x¬≤</span> + <span id="b-val" class="param-value">0.0</span></div>
        
        <div class="slider-group">
            <label>STRETCH (a) <span id="a-display">1.0</span></label>
            <input type="range" id="a-slider" min="-3.0" max="3.0" value="1.0" step="0.05">
        </div>
        <div class="slider-group">
            <label>TRANSLATE (b) <span id="b-display">0.0</span></label>
            <input type="range" id="b-slider" min="-3.0" max="3.0" value="0.0" step="0.05">
        </div>
        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px; color: #aaf;">
            <span style="border:1px solid #0ff; padding:5px 15px; border-radius:40px;">‚ÜïÔ∏è stretch</span>
            <span style="border:1px solid #f0f; padding:5px 15px; border-radius:40px;">üîÑ reflect</span>
            <span style="border:1px solid #ff0; padding:5px 15px; border-radius:40px;">‚¨ÜÔ∏è translate</span>
        </div>
    </div>

    <div id="footer">¬© 2026 ACHIEVER GROUP TUTIONS ¬∑ 3D GRAPH SPACE</div>

    <!-- Three.js imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // --- setup scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020210);
        scene.fog = new THREE.FogExp2(0x020210, 0.0025);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(12, 6, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.6;
        document.body.appendChild(renderer.domElement);

        // controls with auto-rotate to give "flying" feel
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;
        controls.enableZoom = true;
        controls.zoomSpeed = 1.2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.minDistance = 4;
        controls.maxDistance = 50;

        // --- POST PROCESSING (glow) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.3, 0.9);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.3;
        bloomPass.radius = 0.4;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // FXAA
        const effectFXAA = new ShaderPass(FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(effectFXAA);

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0x404080);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xaaccff, 1.0);
        dirLight.position.set(5, 12, 8);
        scene.add(dirLight);

        const pointLight1 = new THREE.PointLight(0x3366ff, 1.2, 40);
        pointLight1.position.set(-5, 4, 8);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff44aa, 0.9, 40);
        pointLight2.position.set(6, 3, -8);
        scene.add(pointLight2);

        // --- INFINITE GLOWING AXES (neon) ---
        const axesHelper = new THREE.AxesHelper(20); // we replace with custom glowing lines
        const axisMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        
        // X axis (cyan)
        const xAxisPoints = [new THREE.Vector3(-30, 0, 0), new THREE.Vector3(30, 0, 0)];
        const xAxisGeo = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
        const xAxisLine = new THREE.Line(xAxisGeo, axisMaterial);
        scene.add(xAxisLine);

        // Y axis (magenta)
        const yAxisPoints = [new THREE.Vector3(0, -30, 0), new THREE.Vector3(0, 30, 0)];
        const yAxisGeo = new THREE.BufferGeometry().setFromPoints(yAxisPoints);
        const yAxisLine = new THREE.Line(yAxisGeo, new THREE.LineBasicMaterial({ color: 0xff44ff }));
        scene.add(yAxisLine);

        // Z axis (blue)
        const zAxisPoints = [new THREE.Vector3(0, 0, -30), new THREE.Vector3(0, 0, 30)];
        const zAxisGeo = new THREE.BufferGeometry().setFromPoints(zAxisPoints);
        const zAxisLine = new THREE.Line(zAxisGeo, new THREE.LineBasicMaterial({ color: 0xaaaaff }));
        scene.add(zAxisLine);

        // --- NEON GRID (glowing) ---
        const gridSize = 30;
        const divisions = 40;
        const gridColor = 0x2266ff;
        const gridHelper = new THREE.GridHelper(gridSize, divisions, gridColor, 0x114488);
        gridHelper.position.y = -0.01;
        gridHelper.material.opacity = 0.4;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // additional floating small grid lines to enhance depth (XZ planes repeated)
        for (let y = -5; y <= 5; y+=2.5) {
            if (Math.abs(y) < 0.1) continue;
            const g = new THREE.GridHelper(25, 20, 0x3366aa, 0x224466);
            g.position.y = y;
            g.material.opacity = 0.15;
            g.material.transparent = true;
            scene.add(g);
        }

        // --- PARTICLE BACKGROUND (subtle, floating) ---
        const particleGeo = new THREE.BufferGeometry();
        const particleCount = 1500;
        const posArray = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            posArray[i*3] = (Math.random() - 0.5) * 100;
            posArray[i*3+1] = (Math.random() - 0.5) * 60;
            posArray[i*3+2] = (Math.random() - 0.5) * 100;
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particleMat = new THREE.PointsMaterial({ color: 0x88aaff, size: 0.18, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.5 });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // --- LUMINOUS CURVE (function y = a*x¬≤ + b) rendered as LineSegments with glow ---
        const curveGroup = new THREE.Group();
        scene.add(curveGroup);

        let curveLine; // reference

        function createCurve(a, b) {
            const points = [];
            const range = 5.0;
            const steps = 200;
            for (let i = 0; i <= steps; i++) {
                const x = -range + (i / steps) * (2 * range);
                const y = a * x * x + b;   // classic parabola
                const z = 0; // flat on XZ plane? But we want 3D: we can also make it 3D by using z = x*0? Keep 2D in XY plane.
                // Actually we want it floating in 3D space, use XY plane (Y up), and Z=0.
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffaa33 }); // will be overridden by bloom
            const line = new THREE.Line(geometry, material);
            
            // also create small glowing spheres along the curve for extra effect
            const sphereGroup = new THREE.Group();
            const stepSmall = 8;
            for (let i = 0; i <= steps; i+= stepSmall) {
                const x = -range + (i / steps) * (2 * range);
                const y = a * x * x + b;
                const sphereGeo = new THREE.SphereGeometry(0.08, 6, 6);
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0xffaa33, emissive: 0x442200 });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                sphere.position.set(x, y, 0);
                sphereGroup.add(sphere);
            }
            
            return { line, spheres: sphereGroup };
        }

        function updateCurve(a, b) {
            curveGroup.clear();
            const { line, spheres } = createCurve(a, b);
            curveGroup.add(line);
            curveGroup.add(spheres);
            
            // update UI
            document.getElementById('a-display').textContent = a.toFixed(2);
            document.getElementById('b-display').textContent = b.toFixed(2);
            document.getElementById('a-val').textContent = a.toFixed(2);
            document.getElementById('b-val').textContent = b.toFixed(2);
        }

        // initial
        let a = 1.0, b = 0.0;
        updateCurve(a, b);

        // --- SLIDER CONTROLS ---
        const aSlider = document.getElementById('a-slider');
        const bSlider = document.getElementById('b-slider');
        
        aSlider.addEventListener('input', (e) => {
            a = parseFloat(e.target.value);
            updateCurve(a, b);
        });
        bSlider.addEventListener('input', (e) => {
            b = parseFloat(e.target.value);
            updateCurve(a, b);
        });

        // --- ADDITIONAL TRANSFORMATION VISUALS (reflection: sign of a, translation: b) handled above ---
        
        // --- ZOOM-IN EFFECT: we can animate camera or just rely on controls; add hint that scroll zooms into curve.
        // Also we can add a pulsing effect near curve when zoomed.
        
        // --- FLOATING LABELS (simple sprites for a,b,c) Not necessary, we have HUD.

        // --- Add some glowing orbs along axes to emphasize dimension
        const markerMat = new THREE.MeshStandardMaterial({ color: 0x44aaff, emissive: 0x113366 });
        for (let i = -4; i <= 4; i++) {
            if (i === 0) continue;
            const sphereX = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), markerMat);
            sphereX.position.set(i*2, 0, 0);
            scene.add(sphereX);
            
            const sphereY = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), markerMat);
            sphereY.position.set(0, i*2, 0);
            scene.add(sphereY);
            
            const sphereZ = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), markerMat);
            sphereZ.position.set(0, 0, i*2);
            scene.add(sphereZ);
        }

        // --- Animated transformation hints: small floating digits
        const digitGroup = new THREE.Group();
        for (let i=0; i<12; i++) {
            const geo = new THREE.TorusGeometry(0.12, 0.03, 8, 20);
            const mat = new THREE.MeshStandardMaterial({ color: 0x88ccff, emissive: 0x224466 });
            const ring = new THREE.Mesh(geo, mat);
            ring.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*6, (Math.random()-0.5)*10);
            ring.rotation.x = Math.random()*Math.PI;
            ring.rotation.y = Math.random()*Math.PI;
            digitGroup.add(ring);
        }
        scene.add(digitGroup);

        // --- Animation loop ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;

            // subtle floating for particles
            particles.rotation.y += 0.0001;
            
            // rotate digit rings
            digitGroup.rotation.y += 0.001;
            digitGroup.rotation.x += 0.0005;

            // make the curve spheres pulsate slightly
            curveGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(sp => {
                        sp.scale.setScalar(1.0 + Math.sin(time*3 + sp.position.x)*0.1);
                    });
                }
            });

            controls.update(); // auto-rotate enabled

            composer.render();

            requestAnimationFrame(animate);
        }

        animate();

        // resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        });

        // Add a subtle zoom transition hint: on zoom, increase glow? not needed.
        console.log('Algebra Explorer ready');
    </script>
</body>
</html>
